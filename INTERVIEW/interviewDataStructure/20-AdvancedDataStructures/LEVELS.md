# üèóÔ∏è ADVANCED DATA STRUCTURES - 20 LEVELS

## üìö **T·ªïng quan**
Advanced Data Structures l√† c√°c c·∫•u tr√∫c d·ªØ li·ªáu ph·ª©c t·∫°p ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ gi·∫£i quy·∫øt c√°c b√†i to√°n n√¢ng cao trong l·∫≠p tr√¨nh thi ƒë·∫•u v√† ph·ªèng v·∫•n.

---

## üéØ **LEVEL 1: TRIE C∆† B·∫¢N**
### **B√†i to√°n**: Implement Trie (Prefix Tree)

#### **Python Solution:**
```python
def trie_c∆°_b·∫£n(arr):
    # Implementation for TRIE C∆† B·∫¢N
    n = len(arr)
    # Add your logic here
    return arr

# Example usage
arr = [1, 2, 3, 4, 5]
result = trie_c∆°_b·∫£n(arr)
print(f"Result: {result}")
```

#### **C++ Solution:**
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> trie_c∆°_b·∫£n(vector<int>& arr) {
    // Implementation for TRIE C∆† B·∫¢N
    int n = arr.size();
    // Add your logic here
    return arr;
}

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    vector<int> result = trie_c∆°_b·∫£n(arr);
    
    cout << "Result: ";
    for (int num : result) cout << num << " ";
    cout << endl;
    return 0;
}
```

#### **C Solution:**
```c
#include <stdio.h>

void trie_c∆°_b·∫£n(int arr[], int n) {
    // Implementation for TRIE C∆† B·∫¢N
    // Add your logic here
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    trie_c∆°_b·∫£n(arr, n);
    
    printf("Result: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    return 0;
}
```

#### **Java Solution:**
```java
import java.util.Arrays;

public class TRIEC∆†B·∫¢N {
    public static int[] trie_c∆°_b·∫£n(int[] arr) {
        // Implementation for TRIE C∆† B·∫¢N
        int n = arr.length;
        // Add your logic here
        return arr;
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        int[] result = trie_c∆°_b·∫£n(arr);
        
        System.out.println("Result: " + Arrays.toString(result));
    }
}
```

---

---

## üéØ **LEVEL 2: TRIE V·ªöI COUNT**
### **B√†i to√°n**: Trie v·ªõi ƒë·∫øm s·ªë t·ª´ c√≥ prefix

#### **Python Solution:**
```python
def trie_v·ªõi_count(arr):
    # Implementation for TRIE V·ªöI COUNT
    n = len(arr)
    # Add your logic here
    return arr

# Example usage
arr = [1, 2, 3, 4, 5]
result = trie_v·ªõi_count(arr)
print(f"Result: {result}")
```

#### **C++ Solution:**
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> trie_v·ªõi_count(vector<int>& arr) {
    // Implementation for TRIE V·ªöI COUNT
    int n = arr.size();
    // Add your logic here
    return arr;
}

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    vector<int> result = trie_v·ªõi_count(arr);
    
    cout << "Result: ";
    for (int num : result) cout << num << " ";
    cout << endl;
    return 0;
}
```

#### **C Solution:**
```c
#include <stdio.h>

void trie_v·ªõi_count(int arr[], int n) {
    // Implementation for TRIE V·ªöI COUNT
    // Add your logic here
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    trie_v·ªõi_count(arr, n);
    
    printf("Result: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    return 0;
}
```

#### **Java Solution:**
```java
import java.util.Arrays;

public class TRIEV·ªöICOUNT {
    public static int[] trie_v·ªõi_count(int[] arr) {
        // Implementation for TRIE V·ªöI COUNT
        int n = arr.length;
        // Add your logic here
        return arr;
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        int[] result = trie_v·ªõi_count(arr);
        
        System.out.println("Result: " + Arrays.toString(result));
    }
}
```

---

---

## üéØ **LEVEL 3: TRIE V·ªöI WILDCARD**
### **B√†i to√°n**: Word Search II v·ªõi wildcard

#### **Python Solution:**
```python
def trie_v·ªõi_wildcard(arr):
    # Implementation for TRIE V·ªöI WILDCARD
    n = len(arr)
    # Add your logic here
    return arr

# Example usage
arr = [1, 2, 3, 4, 5]
result = trie_v·ªõi_wildcard(arr)
print(f"Result: {result}")
```

#### **C++ Solution:**
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> trie_v·ªõi_wildcard(vector<int>& arr) {
    // Implementation for TRIE V·ªöI WILDCARD
    int n = arr.size();
    // Add your logic here
    return arr;
}

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    vector<int> result = trie_v·ªõi_wildcard(arr);
    
    cout << "Result: ";
    for (int num : result) cout << num << " ";
    cout << endl;
    return 0;
}
```

#### **C Solution:**
```c
#include <stdio.h>

void trie_v·ªõi_wildcard(int arr[], int n) {
    // Implementation for TRIE V·ªöI WILDCARD
    // Add your logic here
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    trie_v·ªõi_wildcard(arr, n);
    
    printf("Result: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    return 0;
}
```

#### **Java Solution:**
```java
import java.util.Arrays;

public class TRIEV·ªöIWILDCARD {
    public static int[] trie_v·ªõi_wildcard(int[] arr) {
        // Implementation for TRIE V·ªöI WILDCARD
        int n = arr.length;
        // Add your logic here
        return arr;
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        int[] result = trie_v·ªõi_wildcard(arr);
        
        System.out.println("Result: " + Arrays.toString(result));
    }
}
```

---

---

## üéØ **LEVEL 4: SEGMENT TREE C∆† B·∫¢N**
### **B√†i to√°n**: Range Sum Query - Mutable

#### **Python Solution:**
```python
def segment_tree_c∆°_b·∫£n(arr):
    # Implementation for SEGMENT TREE C∆† B·∫¢N
    n = len(arr)
    # Add your logic here
    return arr

# Example usage
arr = [1, 2, 3, 4, 5]
result = segment_tree_c∆°_b·∫£n(arr)
print(f"Result: {result}")
```

#### **C++ Solution:**
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> segment_tree_c∆°_b·∫£n(vector<int>& arr) {
    // Implementation for SEGMENT TREE C∆† B·∫¢N
    int n = arr.size();
    // Add your logic here
    return arr;
}

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    vector<int> result = segment_tree_c∆°_b·∫£n(arr);
    
    cout << "Result: ";
    for (int num : result) cout << num << " ";
    cout << endl;
    return 0;
}
```

#### **C Solution:**
```c
#include <stdio.h>

void segment_tree_c∆°_b·∫£n(int arr[], int n) {
    // Implementation for SEGMENT TREE C∆† B·∫¢N
    // Add your logic here
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    segment_tree_c∆°_b·∫£n(arr, n);
    
    printf("Result: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    return 0;
}
```

#### **Java Solution:**
```java
import java.util.Arrays;

public class SEGMENTTREEC∆†B·∫¢N {
    public static int[] segment_tree_c∆°_b·∫£n(int[] arr) {
        // Implementation for SEGMENT TREE C∆† B·∫¢N
        int n = arr.length;
        // Add your logic here
        return arr;
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        int[] result = segment_tree_c∆°_b·∫£n(arr);
        
        System.out.println("Result: " + Arrays.toString(result));
    }
}
```

---

---

## üéØ **LEVEL 5: SEGMENT TREE V·ªöI MIN/MAX**
### **B√†i to√°n**: Range Minimum Query

#### **Python Solution:**
```python
def segment_tree_v·ªõi_min/max(arr):
    # Implementation for SEGMENT TREE V·ªöI MIN/MAX
    n = len(arr)
    # Add your logic here
    return arr

# Example usage
arr = [1, 2, 3, 4, 5]
result = segment_tree_v·ªõi_min/max(arr)
print(f"Result: {result}")
```

#### **C++ Solution:**
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> segment_tree_v·ªõi_min/max(vector<int>& arr) {
    // Implementation for SEGMENT TREE V·ªöI MIN/MAX
    int n = arr.size();
    // Add your logic here
    return arr;
}

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    vector<int> result = segment_tree_v·ªõi_min/max(arr);
    
    cout << "Result: ";
    for (int num : result) cout << num << " ";
    cout << endl;
    return 0;
}
```

#### **C Solution:**
```c
#include <stdio.h>

void segment_tree_v·ªõi_min/max(int arr[], int n) {
    // Implementation for SEGMENT TREE V·ªöI MIN/MAX
    // Add your logic here
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    segment_tree_v·ªõi_min/max(arr, n);
    
    printf("Result: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    return 0;
}
```

#### **Java Solution:**
```java
import java.util.Arrays;

public class SEGMENTTREEV·ªöIMIN/MAX {
    public static int[] segment_tree_v·ªõi_min/max(int[] arr) {
        // Implementation for SEGMENT TREE V·ªöI MIN/MAX
        int n = arr.length;
        // Add your logic here
        return arr;
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        int[] result = segment_tree_v·ªõi_min/max(arr);
        
        System.out.println("Result: " + Arrays.toString(result));
    }
}
```

---

---

## üéØ **LEVEL 6: FENWICK TREE C∆† B·∫¢N**
### **B√†i to√°n**: Binary Indexed Tree cho prefix sum

#### **Python Solution:**
```python
def fenwick_tree_c∆°_b·∫£n(arr):
    # Implementation for FENWICK TREE C∆† B·∫¢N
    n = len(arr)
    # Add your logic here
    return arr

# Example usage
arr = [1, 2, 3, 4, 5]
result = fenwick_tree_c∆°_b·∫£n(arr)
print(f"Result: {result}")
```

#### **C++ Solution:**
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> fenwick_tree_c∆°_b·∫£n(vector<int>& arr) {
    // Implementation for FENWICK TREE C∆† B·∫¢N
    int n = arr.size();
    // Add your logic here
    return arr;
}

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    vector<int> result = fenwick_tree_c∆°_b·∫£n(arr);
    
    cout << "Result: ";
    for (int num : result) cout << num << " ";
    cout << endl;
    return 0;
}
```

#### **C Solution:**
```c
#include <stdio.h>

void fenwick_tree_c∆°_b·∫£n(int arr[], int n) {
    // Implementation for FENWICK TREE C∆† B·∫¢N
    // Add your logic here
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    fenwick_tree_c∆°_b·∫£n(arr, n);
    
    printf("Result: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    return 0;
}
```

#### **Java Solution:**
```java
import java.util.Arrays;

public class FENWICKTREEC∆†B·∫¢N {
    public static int[] fenwick_tree_c∆°_b·∫£n(int[] arr) {
        // Implementation for FENWICK TREE C∆† B·∫¢N
        int n = arr.length;
        // Add your logic here
        return arr;
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        int[] result = fenwick_tree_c∆°_b·∫£n(arr);
        
        System.out.println("Result: " + Arrays.toString(result));
    }
}
```

---

---

## üéØ **LEVEL 7: FENWICK TREE V·ªöI RANGE UPDATE**
### **B√†i to√°n**: Range Update v√† Point Query

#### **Python Solution:**
```python
def fenwick_tree_v·ªõi_range_update(arr):
    # Implementation for FENWICK TREE V·ªöI RANGE UPDATE
    n = len(arr)
    # Add your logic here
    return arr

# Example usage
arr = [1, 2, 3, 4, 5]
result = fenwick_tree_v·ªõi_range_update(arr)
print(f"Result: {result}")
```

#### **C++ Solution:**
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> fenwick_tree_v·ªõi_range_update(vector<int>& arr) {
    // Implementation for FENWICK TREE V·ªöI RANGE UPDATE
    int n = arr.size();
    // Add your logic here
    return arr;
}

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    vector<int> result = fenwick_tree_v·ªõi_range_update(arr);
    
    cout << "Result: ";
    for (int num : result) cout << num << " ";
    cout << endl;
    return 0;
}
```

#### **C Solution:**
```c
#include <stdio.h>

void fenwick_tree_v·ªõi_range_update(int arr[], int n) {
    // Implementation for FENWICK TREE V·ªöI RANGE UPDATE
    // Add your logic here
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    fenwick_tree_v·ªõi_range_update(arr, n);
    
    printf("Result: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    return 0;
}
```

#### **Java Solution:**
```java
import java.util.Arrays;

public class FENWICKTREEV·ªöIRANGEUPDATE {
    public static int[] fenwick_tree_v·ªõi_range_update(int[] arr) {
        // Implementation for FENWICK TREE V·ªöI RANGE UPDATE
        int n = arr.length;
        // Add your logic here
        return arr;
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        int[] result = fenwick_tree_v·ªõi_range_update(arr);
        
        System.out.println("Result: " + Arrays.toString(result));
    }
}
```

---

---

## üéØ **LEVEL 8: DISJOINT SET C∆† B·∫¢N**
### **B√†i to√°n**: Union Find v·ªõi path compression

#### **Python Solution:**
```python
def disjoint_set_c∆°_b·∫£n(arr):
    # Implementation for DISJOINT SET C∆† B·∫¢N
    n = len(arr)
    # Add your logic here
    return arr

# Example usage
arr = [1, 2, 3, 4, 5]
result = disjoint_set_c∆°_b·∫£n(arr)
print(f"Result: {result}")
```

#### **C++ Solution:**
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> disjoint_set_c∆°_b·∫£n(vector<int>& arr) {
    // Implementation for DISJOINT SET C∆† B·∫¢N
    int n = arr.size();
    // Add your logic here
    return arr;
}

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    vector<int> result = disjoint_set_c∆°_b·∫£n(arr);
    
    cout << "Result: ";
    for (int num : result) cout << num << " ";
    cout << endl;
    return 0;
}
```

#### **C Solution:**
```c
#include <stdio.h>

void disjoint_set_c∆°_b·∫£n(int arr[], int n) {
    // Implementation for DISJOINT SET C∆† B·∫¢N
    // Add your logic here
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    disjoint_set_c∆°_b·∫£n(arr, n);
    
    printf("Result: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    return 0;
}
```

#### **Java Solution:**
```java
import java.util.Arrays;

public class DISJOINTSETC∆†B·∫¢N {
    public static int[] disjoint_set_c∆°_b·∫£n(int[] arr) {
        // Implementation for DISJOINT SET C∆† B·∫¢N
        int n = arr.length;
        // Add your logic here
        return arr;
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        int[] result = disjoint_set_c∆°_b·∫£n(arr);
        
        System.out.println("Result: " + Arrays.toString(result));
    }
}
```

---

---

## üéØ **LEVEL 9: DISJOINT SET V·ªöI SIZE**
### **B√†i to√°n**: Union Find v·ªõi tracking size

#### **Python Solution:**
```python
def disjoint_set_v·ªõi_size(arr):
    # Implementation for DISJOINT SET V·ªöI SIZE
    n = len(arr)
    # Add your logic here
    return arr

# Example usage
arr = [1, 2, 3, 4, 5]
result = disjoint_set_v·ªõi_size(arr)
print(f"Result: {result}")
```

#### **C++ Solution:**
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> disjoint_set_v·ªõi_size(vector<int>& arr) {
    // Implementation for DISJOINT SET V·ªöI SIZE
    int n = arr.size();
    // Add your logic here
    return arr;
}

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    vector<int> result = disjoint_set_v·ªõi_size(arr);
    
    cout << "Result: ";
    for (int num : result) cout << num << " ";
    cout << endl;
    return 0;
}
```

#### **C Solution:**
```c
#include <stdio.h>

void disjoint_set_v·ªõi_size(int arr[], int n) {
    // Implementation for DISJOINT SET V·ªöI SIZE
    // Add your logic here
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    disjoint_set_v·ªõi_size(arr, n);
    
    printf("Result: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    return 0;
}
```

#### **Java Solution:**
```java
import java.util.Arrays;

public class DISJOINTSETV·ªöISIZE {
    public static int[] disjoint_set_v·ªõi_size(int[] arr) {
        // Implementation for DISJOINT SET V·ªöI SIZE
        int n = arr.length;
        // Add your logic here
        return arr;
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        int[] result = disjoint_set_v·ªõi_size(arr);
        
        System.out.println("Result: " + Arrays.toString(result));
    }
}
```

---

---

## üéØ **LEVEL 10: SEGMENT TREE V·ªöI LAZY PROPAGATION**
### **B√†i to√°n**: Range Update v√† Range Query

#### **Python Solution:**
```python
def segment_tree_v·ªõi_lazy_propagation(arr):
    # Implementation for SEGMENT TREE V·ªöI LAZY PROPAGATION
    n = len(arr)
    # Add your logic here
    return arr

# Example usage
arr = [1, 2, 3, 4, 5]
result = segment_tree_v·ªõi_lazy_propagation(arr)
print(f"Result: {result}")
```

#### **C++ Solution:**
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> segment_tree_v·ªõi_lazy_propagation(vector<int>& arr) {
    // Implementation for SEGMENT TREE V·ªöI LAZY PROPAGATION
    int n = arr.size();
    // Add your logic here
    return arr;
}

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    vector<int> result = segment_tree_v·ªõi_lazy_propagation(arr);
    
    cout << "Result: ";
    for (int num : result) cout << num << " ";
    cout << endl;
    return 0;
}
```

#### **C Solution:**
```c
#include <stdio.h>

void segment_tree_v·ªõi_lazy_propagation(int arr[], int n) {
    // Implementation for SEGMENT TREE V·ªöI LAZY PROPAGATION
    // Add your logic here
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    segment_tree_v·ªõi_lazy_propagation(arr, n);
    
    printf("Result: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    return 0;
}
```

#### **Java Solution:**
```java
import java.util.Arrays;

public class SEGMENTTREEV·ªöILAZYPROPAGATION {
    public static int[] segment_tree_v·ªõi_lazy_propagation(int[] arr) {
        // Implementation for SEGMENT TREE V·ªöI LAZY PROPAGATION
        int n = arr.length;
        // Add your logic here
        return arr;
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        int[] result = segment_tree_v·ªõi_lazy_propagation(arr);
        
        System.out.println("Result: " + Arrays.toString(result));
    }
}
```

---

---

## üéØ **LEVEL 11: TRIE V·ªöI XOR**
### **B√†i to√°n**: Maximum XOR of Two Numbers in an Array

#### **Python Solution:**
```python
def trie_v·ªõi_xor(arr):
    # Implementation for TRIE V·ªöI XOR
    n = len(arr)
    # Add your logic here
    return arr

# Example usage
arr = [1, 2, 3, 4, 5]
result = trie_v·ªõi_xor(arr)
print(f"Result: {result}")
```

#### **C++ Solution:**
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> trie_v·ªõi_xor(vector<int>& arr) {
    // Implementation for TRIE V·ªöI XOR
    int n = arr.size();
    // Add your logic here
    return arr;
}

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    vector<int> result = trie_v·ªõi_xor(arr);
    
    cout << "Result: ";
    for (int num : result) cout << num << " ";
    cout << endl;
    return 0;
}
```

#### **C Solution:**
```c
#include <stdio.h>

void trie_v·ªõi_xor(int arr[], int n) {
    // Implementation for TRIE V·ªöI XOR
    // Add your logic here
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    trie_v·ªõi_xor(arr, n);
    
    printf("Result: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    return 0;
}
```

#### **Java Solution:**
```java
import java.util.Arrays;

public class TRIEV·ªöIXOR {
    public static int[] trie_v·ªõi_xor(int[] arr) {
        // Implementation for TRIE V·ªöI XOR
        int n = arr.length;
        // Add your logic here
        return arr;
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        int[] result = trie_v·ªõi_xor(arr);
        
        System.out.println("Result: " + Arrays.toString(result));
    }
}
```

---

---

## üéØ **LEVEL 12: SEGMENT TREE V·ªöI GCD**
### **B√†i to√°n**: Range GCD Query

#### **Python Solution:**
```python
def segment_tree_v·ªõi_gcd(arr):
    # Implementation for SEGMENT TREE V·ªöI GCD
    n = len(arr)
    # Add your logic here
    return arr

# Example usage
arr = [1, 2, 3, 4, 5]
result = segment_tree_v·ªõi_gcd(arr)
print(f"Result: {result}")
```

#### **C++ Solution:**
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> segment_tree_v·ªõi_gcd(vector<int>& arr) {
    // Implementation for SEGMENT TREE V·ªöI GCD
    int n = arr.size();
    // Add your logic here
    return arr;
}

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    vector<int> result = segment_tree_v·ªõi_gcd(arr);
    
    cout << "Result: ";
    for (int num : result) cout << num << " ";
    cout << endl;
    return 0;
}
```

#### **C Solution:**
```c
#include <stdio.h>

void segment_tree_v·ªõi_gcd(int arr[], int n) {
    // Implementation for SEGMENT TREE V·ªöI GCD
    // Add your logic here
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    segment_tree_v·ªõi_gcd(arr, n);
    
    printf("Result: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    return 0;
}
```

#### **Java Solution:**
```java
import java.util.Arrays;

public class SEGMENTTREEV·ªöIGCD {
    public static int[] segment_tree_v·ªõi_gcd(int[] arr) {
        // Implementation for SEGMENT TREE V·ªöI GCD
        int n = arr.length;
        // Add your logic here
        return arr;
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        int[] result = segment_tree_v·ªõi_gcd(arr);
        
        System.out.println("Result: " + Arrays.toString(result));
    }
}
```

---

---

## üéØ **LEVEL 13: FENWICK TREE V·ªöI 2D**
### **B√†i to√°n**: 2D Binary Indexed Tree

#### **Python Solution:**
```python
def fenwick_tree_v·ªõi_2d(arr):
    # Implementation for FENWICK TREE V·ªöI 2D
    n = len(arr)
    # Add your logic here
    return arr

# Example usage
arr = [1, 2, 3, 4, 5]
result = fenwick_tree_v·ªõi_2d(arr)
print(f"Result: {result}")
```

#### **C++ Solution:**
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> fenwick_tree_v·ªõi_2d(vector<int>& arr) {
    // Implementation for FENWICK TREE V·ªöI 2D
    int n = arr.size();
    // Add your logic here
    return arr;
}

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    vector<int> result = fenwick_tree_v·ªõi_2d(arr);
    
    cout << "Result: ";
    for (int num : result) cout << num << " ";
    cout << endl;
    return 0;
}
```

#### **C Solution:**
```c
#include <stdio.h>

void fenwick_tree_v·ªõi_2d(int arr[], int n) {
    // Implementation for FENWICK TREE V·ªöI 2D
    // Add your logic here
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    fenwick_tree_v·ªõi_2d(arr, n);
    
    printf("Result: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    return 0;
}
```

#### **Java Solution:**
```java
import java.util.Arrays;

public class FENWICKTREEV·ªöI2D {
    public static int[] fenwick_tree_v·ªõi_2d(int[] arr) {
        // Implementation for FENWICK TREE V·ªöI 2D
        int n = arr.length;
        // Add your logic here
        return arr;
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        int[] result = fenwick_tree_v·ªõi_2d(arr);
        
        System.out.println("Result: " + Arrays.toString(result));
    }
}
```

---

---

## üéØ **LEVEL 14: DISJOINT SET V·ªöI ROLLBACK**
### **B√†i to√°n**: Union Find v·ªõi kh·∫£ nƒÉng rollback

#### **Python Solution:**
```python
def disjoint_set_v·ªõi_rollback(arr):
    # Implementation for DISJOINT SET V·ªöI ROLLBACK
    n = len(arr)
    # Add your logic here
    return arr

# Example usage
arr = [1, 2, 3, 4, 5]
result = disjoint_set_v·ªõi_rollback(arr)
print(f"Result: {result}")
```

#### **C++ Solution:**
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> disjoint_set_v·ªõi_rollback(vector<int>& arr) {
    // Implementation for DISJOINT SET V·ªöI ROLLBACK
    int n = arr.size();
    // Add your logic here
    return arr;
}

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    vector<int> result = disjoint_set_v·ªõi_rollback(arr);
    
    cout << "Result: ";
    for (int num : result) cout << num << " ";
    cout << endl;
    return 0;
}
```

#### **C Solution:**
```c
#include <stdio.h>

void disjoint_set_v·ªõi_rollback(int arr[], int n) {
    // Implementation for DISJOINT SET V·ªöI ROLLBACK
    // Add your logic here
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    disjoint_set_v·ªõi_rollback(arr, n);
    
    printf("Result: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    return 0;
}
```

#### **Java Solution:**
```java
import java.util.Arrays;

public class DISJOINTSETV·ªöIROLLBACK {
    public static int[] disjoint_set_v·ªõi_rollback(int[] arr) {
        // Implementation for DISJOINT SET V·ªöI ROLLBACK
        int n = arr.length;
        // Add your logic here
        return arr;
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        int[] result = disjoint_set_v·ªõi_rollback(arr);
        
        System.out.println("Result: " + Arrays.toString(result));
    }
}
```

---

---

## üéØ **LEVEL 15: SEGMENT TREE V·ªöI PERSISTENT**
### **B√†i to√°n**: Persistent Segment Tree

#### **Python Solution:**
```python
def segment_tree_v·ªõi_persistent(arr):
    # Implementation for SEGMENT TREE V·ªöI PERSISTENT
    n = len(arr)
    # Add your logic here
    return arr

# Example usage
arr = [1, 2, 3, 4, 5]
result = segment_tree_v·ªõi_persistent(arr)
print(f"Result: {result}")
```

#### **C++ Solution:**
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> segment_tree_v·ªõi_persistent(vector<int>& arr) {
    // Implementation for SEGMENT TREE V·ªöI PERSISTENT
    int n = arr.size();
    // Add your logic here
    return arr;
}

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    vector<int> result = segment_tree_v·ªõi_persistent(arr);
    
    cout << "Result: ";
    for (int num : result) cout << num << " ";
    cout << endl;
    return 0;
}
```

#### **C Solution:**
```c
#include <stdio.h>

void segment_tree_v·ªõi_persistent(int arr[], int n) {
    // Implementation for SEGMENT TREE V·ªöI PERSISTENT
    // Add your logic here
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    segment_tree_v·ªõi_persistent(arr, n);
    
    printf("Result: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    return 0;
}
```

#### **Java Solution:**
```java
import java.util.Arrays;

public class SEGMENTTREEV·ªöIPERSISTENT {
    public static int[] segment_tree_v·ªõi_persistent(int[] arr) {
        // Implementation for SEGMENT TREE V·ªöI PERSISTENT
        int n = arr.length;
        // Add your logic here
        return arr;
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        int[] result = segment_tree_v·ªõi_persistent(arr);
        
        System.out.println("Result: " + Arrays.toString(result));
    }
}
```

---

---

## üéØ **LEVEL 16: TRIE V·ªöI COMPRESSED**
### **B√†i to√°n**: Compressed Trie (Radix Tree)

#### **Python Solution:**
```python
def trie_v·ªõi_compressed(arr):
    # Implementation for TRIE V·ªöI COMPRESSED
    n = len(arr)
    # Add your logic here
    return arr

# Example usage
arr = [1, 2, 3, 4, 5]
result = trie_v·ªõi_compressed(arr)
print(f"Result: {result}")
```

#### **C++ Solution:**
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> trie_v·ªõi_compressed(vector<int>& arr) {
    // Implementation for TRIE V·ªöI COMPRESSED
    int n = arr.size();
    // Add your logic here
    return arr;
}

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    vector<int> result = trie_v·ªõi_compressed(arr);
    
    cout << "Result: ";
    for (int num : result) cout << num << " ";
    cout << endl;
    return 0;
}
```

#### **C Solution:**
```c
#include <stdio.h>

void trie_v·ªõi_compressed(int arr[], int n) {
    // Implementation for TRIE V·ªöI COMPRESSED
    // Add your logic here
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    trie_v·ªõi_compressed(arr, n);
    
    printf("Result: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    return 0;
}
```

#### **Java Solution:**
```java
import java.util.Arrays;

public class TRIEV·ªöICOMPRESSED {
    public static int[] trie_v·ªõi_compressed(int[] arr) {
        // Implementation for TRIE V·ªöI COMPRESSED
        int n = arr.length;
        // Add your logic here
        return arr;
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        int[] result = trie_v·ªõi_compressed(arr);
        
        System.out.println("Result: " + Arrays.toString(result));
    }
}
```

---

---

## üéØ **LEVEL 17: SEGMENT TREE V·ªöI MERGE SORT**
### **B√†i to√°n**: Merge Sort Tree cho range queries

#### **Python Solution:**
```python
def segment_tree_v·ªõi_merge_sort(arr):
    # Implementation for SEGMENT TREE V·ªöI MERGE SORT
    n = len(arr)
    # Add your logic here
    return arr

# Example usage
arr = [1, 2, 3, 4, 5]
result = segment_tree_v·ªõi_merge_sort(arr)
print(f"Result: {result}")
```

#### **C++ Solution:**
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> segment_tree_v·ªõi_merge_sort(vector<int>& arr) {
    // Implementation for SEGMENT TREE V·ªöI MERGE SORT
    int n = arr.size();
    // Add your logic here
    return arr;
}

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    vector<int> result = segment_tree_v·ªõi_merge_sort(arr);
    
    cout << "Result: ";
    for (int num : result) cout << num << " ";
    cout << endl;
    return 0;
}
```

#### **C Solution:**
```c
#include <stdio.h>

void segment_tree_v·ªõi_merge_sort(int arr[], int n) {
    // Implementation for SEGMENT TREE V·ªöI MERGE SORT
    // Add your logic here
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    segment_tree_v·ªõi_merge_sort(arr, n);
    
    printf("Result: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    return 0;
}
```

#### **Java Solution:**
```java
import java.util.Arrays;

public class SEGMENTTREEV·ªöIMERGESORT {
    public static int[] segment_tree_v·ªõi_merge_sort(int[] arr) {
        // Implementation for SEGMENT TREE V·ªöI MERGE SORT
        int n = arr.length;
        // Add your logic here
        return arr;
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        int[] result = segment_tree_v·ªõi_merge_sort(arr);
        
        System.out.println("Result: " + Arrays.toString(result));
    }
}
```

---

---

## üéØ **LEVEL 18: FENWICK TREE V·ªöI RANGE MIN/MAX**
### **B√†i to√°n**: Range Minimum/Maximum v·ªõi Fenwick Tree

#### **Python Solution:**
```python
def fenwick_tree_v·ªõi_range_min/max(arr):
    # Implementation for FENWICK TREE V·ªöI RANGE MIN/MAX
    n = len(arr)
    # Add your logic here
    return arr

# Example usage
arr = [1, 2, 3, 4, 5]
result = fenwick_tree_v·ªõi_range_min/max(arr)
print(f"Result: {result}")
```

#### **C++ Solution:**
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> fenwick_tree_v·ªõi_range_min/max(vector<int>& arr) {
    // Implementation for FENWICK TREE V·ªöI RANGE MIN/MAX
    int n = arr.size();
    // Add your logic here
    return arr;
}

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    vector<int> result = fenwick_tree_v·ªõi_range_min/max(arr);
    
    cout << "Result: ";
    for (int num : result) cout << num << " ";
    cout << endl;
    return 0;
}
```

#### **C Solution:**
```c
#include <stdio.h>

void fenwick_tree_v·ªõi_range_min/max(int arr[], int n) {
    // Implementation for FENWICK TREE V·ªöI RANGE MIN/MAX
    // Add your logic here
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    fenwick_tree_v·ªõi_range_min/max(arr, n);
    
    printf("Result: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    return 0;
}
```

#### **Java Solution:**
```java
import java.util.Arrays;

public class FENWICKTREEV·ªöIRANGEMIN/MAX {
    public static int[] fenwick_tree_v·ªõi_range_min/max(int[] arr) {
        // Implementation for FENWICK TREE V·ªöI RANGE MIN/MAX
        int n = arr.length;
        // Add your logic here
        return arr;
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        int[] result = fenwick_tree_v·ªõi_range_min/max(arr);
        
        System.out.println("Result: " + Arrays.toString(result));
    }
}
```

---

---

## üéØ **LEVEL 19: DISJOINT SET V·ªöI WEIGHTED**
### **B√†i to√°n**: Weighted Union Find

#### **Python Solution:**
```python
def disjoint_set_v·ªõi_weighted(arr):
    # Implementation for DISJOINT SET V·ªöI WEIGHTED
    n = len(arr)
    # Add your logic here
    return arr

# Example usage
arr = [1, 2, 3, 4, 5]
result = disjoint_set_v·ªõi_weighted(arr)
print(f"Result: {result}")
```

#### **C++ Solution:**
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> disjoint_set_v·ªõi_weighted(vector<int>& arr) {
    // Implementation for DISJOINT SET V·ªöI WEIGHTED
    int n = arr.size();
    // Add your logic here
    return arr;
}

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    vector<int> result = disjoint_set_v·ªõi_weighted(arr);
    
    cout << "Result: ";
    for (int num : result) cout << num << " ";
    cout << endl;
    return 0;
}
```

#### **C Solution:**
```c
#include <stdio.h>

void disjoint_set_v·ªõi_weighted(int arr[], int n) {
    // Implementation for DISJOINT SET V·ªöI WEIGHTED
    // Add your logic here
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    disjoint_set_v·ªõi_weighted(arr, n);
    
    printf("Result: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    return 0;
}
```

#### **Java Solution:**
```java
import java.util.Arrays;

public class DISJOINTSETV·ªöIWEIGHTED {
    public static int[] disjoint_set_v·ªõi_weighted(int[] arr) {
        // Implementation for DISJOINT SET V·ªöI WEIGHTED
        int n = arr.length;
        // Add your logic here
        return arr;
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        int[] result = disjoint_set_v·ªõi_weighted(arr);
        
        System.out.println("Result: " + Arrays.toString(result));
    }
}
```

---

---

## üéØ **LEVEL 20: ADVANCED HYBRID STRUCTURES**
### **B√†i to√°n**: Combination c·ªßa nhi·ªÅu c·∫•u tr√∫c d·ªØ li·ªáu

#### **Python Solution:**
```python
def advanced_hybrid_structures(arr):
    # Implementation for ADVANCED HYBRID STRUCTURES
    n = len(arr)
    # Add your logic here
    return arr

# Example usage
arr = [1, 2, 3, 4, 5]
result = advanced_hybrid_structures(arr)
print(f"Result: {result}")
```

#### **C++ Solution:**
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> advanced_hybrid_structures(vector<int>& arr) {
    // Implementation for ADVANCED HYBRID STRUCTURES
    int n = arr.size();
    // Add your logic here
    return arr;
}

int main() {
    vector<int> arr = {1, 2, 3, 4, 5};
    vector<int> result = advanced_hybrid_structures(arr);
    
    cout << "Result: ";
    for (int num : result) cout << num << " ";
    cout << endl;
    return 0;
}
```

#### **C Solution:**
```c
#include <stdio.h>

void advanced_hybrid_structures(int arr[], int n) {
    // Implementation for ADVANCED HYBRID STRUCTURES
    // Add your logic here
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    advanced_hybrid_structures(arr, n);
    
    printf("Result: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
    return 0;
}
```

#### **Java Solution:**
```java
import java.util.Arrays;

public class ADVANCEDHYBRIDSTRUCTURES {
    public static int[] advanced_hybrid_structures(int[] arr) {
        // Implementation for ADVANCED HYBRID STRUCTURES
        int n = arr.length;
        // Add your logic here
        return arr;
    }
    
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        int[] result = advanced_hybrid_structures(arr);
        
        System.out.println("Result: " + Arrays.toString(result));
    }
}
```

---

---

## üéØ **T·ªîNG K·∫æT 20 LEVELS**

### **Giai ƒëo·∫°n 1 (Level 1-5)**: C∆° b·∫£n
- Trie c∆° b·∫£n v√† n√¢ng cao
- Segment Tree c∆° b·∫£n
- Fenwick Tree c∆° b·∫£n
- Disjoint Set c∆° b·∫£n

### **Giai ƒëo·∫°n 2 (Level 6-10)**: N√¢ng cao
- Lazy propagation
- Range operations
- Size tracking
- Advanced queries

### **Giai ƒëo·∫°n 3 (Level 11-15)**: Chuy√™n s√¢u
- XOR operations
- GCD queries
- 2D structures
- Persistent structures

### **Giai ƒëo·∫°n 4 (Level 16-20)**: Master
- Compressed structures
- Merge sort trees
- Weighted operations
- Hybrid combinations

---

## üí° **·ª®ng d·ª•ng th·ª±c t·∫ø**

### **Trie:**
- Autocomplete systems
- Spell checkers
- IP routing tables
- DNA sequence analysis

### **Segment Tree:**
- Range queries in databases
- Image processing
- Geographic information systems
- Financial data analysis

### **Fenwick Tree:**
- Cumulative frequency counting
- Inversion counting
- Range sum queries
- Dynamic programming optimization

### **Disjoint Set:**
- Network connectivity
- Image segmentation
- Kruskal's algorithm
- Cycle detection in graphs

---

## üöÄ **Next Steps**

1. **Practice implementation** c·ªßa t·ª´ng c·∫•u tr√∫c
2. **Solve problems** tr√™n LeetCode/HackerRank
3. **Optimize performance** cho t·ª´ng use case
4. **Combine structures** cho complex problems
5. **Apply to real projects** ƒë·ªÉ hi·ªÉu s√¢u h∆°n

---

**üéâ Ch√∫c b·∫°n th√†nh th·∫°o Advanced Data Structures! üéâ** 