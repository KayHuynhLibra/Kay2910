# SUBSETS - 10 LEVELS T·ª™ C∆† B·∫¢N ƒê·∫æN N√ÇNG CAO

## üéØ T·ªïng quan
10 level n√†y ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ b·∫°n h·ªçc Subsets t·ª´ c∆° b·∫£n ƒë·∫øn n√¢ng cao.

---

## üìö **LEVEL 1: Hi·ªÉu c∆° b·∫£n v·ªÅ Subsets**
**M·ª•c ti√™u**: Hi·ªÉu kh√°i ni·ªám v√† c√°ch ho·∫°t ƒë·ªông c·ªßa subsets

### B√†i to√°n: Subsets
```python
def subsets(nums):
    """
    T√¨m t·∫•t c·∫£ subsets c·ªßa m·∫£ng
    """
    result = []
    
    def backtrack(start, current):
        result.append(current[:])
        
        for i in range(start, len(nums)):
            current.append(nums[i])
            backtrack(i + 1, current)
            current.pop()
    
    backtrack(0, [])
    return result
```

**ƒê·ªô kh√≥**: ‚≠ê  
**Th·ªùi gian**: O(2^n)  
**Kh√¥ng gian**: O(n)

---

## üìö **LEVEL 2: Subsets II (With Duplicates)**
**M·ª•c ti√™u**: X·ª≠ l√Ω subsets v·ªõi ph·∫ßn t·ª≠ tr√πng l·∫∑p

### B√†i to√°n: Subsets II
```python
def subsets_with_dup(nums):
    """
    T√¨m t·∫•t c·∫£ subsets v·ªõi ph·∫ßn t·ª≠ tr√πng l·∫∑p
    """
    nums.sort()  # S·∫Øp x·∫øp ƒë·ªÉ x·ª≠ l√Ω tr√πng l·∫∑p
    result = []
    
    def backtrack(start, current):
        result.append(current[:])
        
        for i in range(start, len(nums)):
            # B·ªè qua ph·∫ßn t·ª≠ tr√πng l·∫∑p
            if i > start and nums[i] == nums[i - 1]:
                continue
            
            current.append(nums[i])
            backtrack(i + 1, current)
            current.pop()
    
    backtrack(0, [])
    return result
```

**ƒê·ªô kh√≥**: ‚≠ê‚≠ê  
**Th·ªùi gian**: O(2^n)  
**Kh√¥ng gian**: O(n)

---

## üìö **LEVEL 3: Permutations**
**M·ª•c ti√™u**: T√¨m t·∫•t c·∫£ ho√°n v·ªã

### B√†i to√°n: Permutations
```python
def permutations(nums):
    """
    T√¨m t·∫•t c·∫£ ho√°n v·ªã c·ªßa m·∫£ng
    """
    result = []
    
    def backtrack(current):
        if len(current) == len(nums):
            result.append(current[:])
            return
        
        for num in nums:
            if num not in current:
                current.append(num)
                backtrack(current)
                current.pop()
    
    backtrack([])
    return result
```

**ƒê·ªô kh√≥**: ‚≠ê‚≠ê‚≠ê  
**Th·ªùi gian**: O(n!)  
**Kh√¥ng gian**: O(n)

---

## üìö **LEVEL 4: Permutations II (With Duplicates)**
**M·ª•c ti√™u**: X·ª≠ l√Ω ho√°n v·ªã v·ªõi ph·∫ßn t·ª≠ tr√πng l·∫∑p

### B√†i to√°n: Permutations II
```python
def permutations_ii(nums):
    """
    T√¨m t·∫•t c·∫£ ho√°n v·ªã v·ªõi ph·∫ßn t·ª≠ tr√πng l·∫∑p
    """
    nums.sort()
    result = []
    used = [False] * len(nums)
    
    def backtrack(current):
        if len(current) == len(nums):
            result.append(current[:])
            return
        
        for i in range(len(nums)):
            if used[i] or (i > 0 and nums[i] == nums[i - 1] and not used[i - 1]):
                continue
            
            used[i] = True
            current.append(nums[i])
            backtrack(current)
            current.pop()
            used[i] = False
    
    backtrack([])
    return result
```

**ƒê·ªô kh√≥**: ‚≠ê‚≠ê‚≠ê‚≠ê  
**Th·ªùi gian**: O(n!)  
**Kh√¥ng gian**: O(n)

---

## üìö **LEVEL 5: Combination Sum**
**M·ª•c ti√™u**: T√¨m t·ªï h·ª£p c√≥ t·ªïng b·∫±ng target

### B√†i to√°n: Combination Sum
```python
def combination_sum(candidates, target):
    """
    T√¨m t·ªï h·ª£p c√≥ t·ªïng b·∫±ng target
    """
    result = []
    
    def backtrack(start, current, current_sum):
        if current_sum == target:
            result.append(current[:])
            return
        
        if current_sum > target:
            return
        
        for i in range(start, len(candidates)):
            current.append(candidates[i])
            backtrack(i, current, current_sum + candidates[i])
            current.pop()
    
    backtrack(0, [], 0)
    return result
```

**ƒê·ªô kh√≥**: ‚≠ê‚≠ê‚≠ê‚≠ê  
**Th·ªùi gian**: O(2^n)  
**Kh√¥ng gian**: O(n)

---

## üìö **LEVEL 6: Combination Sum II**
**M·ª•c ti√™u**: T·ªï h·ª£p v·ªõi ƒëi·ªÅu ki·ªán kh√¥ng tr√πng l·∫∑p

### B√†i to√°n: Combination Sum II
```python
def combination_sum_ii(candidates, target):
    """
    T√¨m t·ªï h·ª£p c√≥ t·ªïng b·∫±ng target (kh√¥ng tr√πng l·∫∑p)
    """
    candidates.sort()
    result = []
    
    def backtrack(start, current, current_sum):
        if current_sum == target:
            result.append(current[:])
            return
        
        if current_sum > target:
            return
        
        for i in range(start, len(candidates)):
            if i > start and candidates[i] == candidates[i - 1]:
                continue
            
            current.append(candidates[i])
            backtrack(i + 1, current, current_sum + candidates[i])
            current.pop()
    
    backtrack(0, [], 0)
    return result
```

**ƒê·ªô kh√≥**: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê  
**Th·ªùi gian**: O(2^n)  
**Kh√¥ng gian**: O(n)

---

## üìö **LEVEL 7: Palindrome Partitioning**
**M·ª•c ti√™u**: Ph√¢n ho·∫°ch chu·ªói th√†nh palindrome

### B√†i to√°n: Palindrome Partitioning
```python
def partition(s):
    """
    Ph√¢n ho·∫°ch chu·ªói th√†nh palindrome
    """
    result = []
    
    def is_palindrome(s, start, end):
        while start < end:
            if s[start] != s[end]:
                return False
            start += 1
            end -= 1
        return True
    
    def backtrack(start, current):
        if start == len(s):
            result.append(current[:])
            return
        
        for end in range(start, len(s)):
            if is_palindrome(s, start, end):
                current.append(s[start:end + 1])
                backtrack(end + 1, current)
                current.pop()
    
    backtrack(0, [])
    return result
```

**ƒê·ªô kh√≥**: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê  
**Th·ªùi gian**: O(n * 2^n)  
**Kh√¥ng gian**: O(n)

---

## üìö **LEVEL 8: Generate Parentheses**
**M·ª•c ti√™u**: T·∫°o t·∫•t c·∫£ c·∫∑p d·∫•u ngo·∫∑c h·ª£p l·ªá

### B√†i to√°n: Generate Parentheses
```python
def generate_parentheses(n):
    """
    T·∫°o t·∫•t c·∫£ c·∫∑p d·∫•u ngo·∫∑c h·ª£p l·ªá
    """
    result = []
    
    def backtrack(current, open_count, close_count):
        if len(current) == 2 * n:
            result.append(current)
            return
        
        if open_count < n:
            backtrack(current + "(", open_count + 1, close_count)
        
        if close_count < open_count:
            backtrack(current + ")", open_count, close_count + 1)
    
    backtrack("", 0, 0)
    return result
```

**ƒê·ªô kh√≥**: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê  
**Th·ªùi gian**: O(4^n / sqrt(n))  
**Kh√¥ng gian**: O(n)

---

## üìö **LEVEL 9: Word Search**
**M·ª•c ti√™u**: T√¨m t·ª´ trong ma tr·∫≠n 2D

### B√†i to√°n: Word Search
```python
def word_search(board, word):
    """
    T√¨m t·ª´ trong ma tr·∫≠n 2D
    """
    rows, cols = len(board), len(board[0])
    
    def backtrack(row, col, word_index):
        if word_index == len(word):
            return True
        
        if (row < 0 or row >= rows or col < 0 or col >= cols or 
            board[row][col] != word[word_index]):
            return False
        
        # ƒê√°nh d·∫•u ƒë√£ s·ª≠ d·ª•ng
        temp = board[row][col]
        board[row][col] = '#'
        
        # Th·ª≠ 4 h∆∞·ªõng
        result = (backtrack(row + 1, col, word_index + 1) or
                 backtrack(row - 1, col, word_index + 1) or
                 backtrack(row, col + 1, word_index + 1) or
                 backtrack(row, col - 1, word_index + 1))
        
        # Kh√¥i ph·ª•c
        board[row][col] = temp
        return result
    
    for row in range(rows):
        for col in range(cols):
            if backtrack(row, col, 0):
                return True
    
    return False
```

**ƒê·ªô kh√≥**: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê  
**Th·ªùi gian**: O(m * n * 4^L)  
**Kh√¥ng gian**: O(L)

---

## üìö **LEVEL 10: Advanced Subsets Applications**
**M·ª•c ti√™u**: ·ª®ng d·ª•ng subsets trong b√†i to√°n ph·ª©c t·∫°p

### B√†i to√°n: N-Queens
```python
def solve_n_queens(n):
    """
    Gi·∫£i b√†i to√°n N-Queens
    """
    result = []
    
    def is_safe(board, row, col):
        # Ki·ªÉm tra c·ªôt
        for i in range(row):
            if board[i][col] == 'Q':
                return False
        
        # Ki·ªÉm tra ƒë∆∞·ªùng ch√©o tr√°i tr√™n
        for i, j in zip(range(row - 1, -1, -1), range(col - 1, -1, -1)):
            if board[i][j] == 'Q':
                return False
        
        # Ki·ªÉm tra ƒë∆∞·ªùng ch√©o ph·∫£i tr√™n
        for i, j in zip(range(row - 1, -1, -1), range(col + 1, n)):
            if board[i][j] == 'Q':
                return False
        
        return True
    
    def backtrack(row, board):
        if row == n:
            result.append([''.join(row) for row in board])
            return
        
        for col in range(n):
            if is_safe(board, row, col):
                board[row][col] = 'Q'
                backtrack(row + 1, board)
                board[row][col] = '.'
    
    board = [['.' for _ in range(n)] for _ in range(n)]
    backtrack(0, board)
    return result
```

**ƒê·ªô kh√≥**: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê  
**Th·ªùi gian**: O(n!)  
**Kh√¥ng gian**: O(n¬≤)

---

## üéØ **L·ªô tr√¨nh h·ªçc t·∫≠p**

### **Giai ƒëo·∫°n 1 (Level 1-3)**: N·ªÅn t·∫£ng
- Hi·ªÉu kh√°i ni·ªám subsets v√† backtracking
- Th√†nh th·∫°o subsets c∆° b·∫£n
- L√†m quen v·ªõi pattern c∆° b·∫£n

### **Giai ƒëo·∫°n 2 (Level 4-6)**: N√¢ng cao
- X·ª≠ l√Ω tr√πng l·∫∑p
- Combination problems
- T·ªëi ∆∞u h√≥a thu·∫≠t to√°n

### **Giai ƒëo·∫°n 3 (Level 7-8)**: Chuy√™n s√¢u
- String problems
- Parentheses generation
- T·ªëi ∆∞u h√≥a b·ªô nh·ªõ

### **Giai ƒëo·∫°n 4 (Level 9-10)**: Master
- Matrix problems
- Advanced applications
- Edge cases ph·ª©c t·∫°p

## üí° **M·∫πo cho t·ª´ng level**

- **Level 1-3**: T·∫≠p trung v√†o hi·ªÉu pattern c∆° b·∫£n
- **Level 4-6**: Ch√∫ √Ω ƒë·∫øn vi·ªác x·ª≠ l√Ω tr√πng l·∫∑p
- **Level 7-8**: Hi·ªÉu s√¢u v·ªÅ ·ª©ng d·ª•ng trong chu·ªói
- **Level 9-10**: Th·ª±c h√†nh nhi·ªÅu v√† ph√¢n t√≠ch c√°c tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát

## üî• **Common Patterns**

### **Basic Backtracking**
```python
def backtrack(start, current):
    # Base case
    if condition:
        result.append(current[:])
        return
    
    for i in range(start, n):
        current.append(nums[i])
        backtrack(i + 1, current)
        current.pop()  # Backtrack
```

### **Handle Duplicates**
```python
nums.sort()
for i in range(start, len(nums)):
    if i > start and nums[i] == nums[i - 1]:
        continue
    # Process
```

### **String Backtracking**
```python
def backtrack(current, start):
    if start == len(s):
        result.append(current[:])
        return
    
    for end in range(start, len(s)):
        if is_valid(s[start:end + 1]):
            current.append(s[start:end + 1])
            backtrack(current, end + 1)
            current.pop()
``` 